// =============================================================================
// CONFIGURACI√ìN DEL JUEGO
// =============================================================================

// Lista de todos los objetos del juego
const gameObjects = [
    'BOTAS', 'BUFANDA', 'CAMPERA', 'Globo Amarillo', 'Globo Azul', 
    'Globo Blanco', 'Globo Naranja', 'Globo Negro', 'Globo Rojo', 
    'Globo Rosa', 'Globo Verde', 'GORRO', 'GUANTES', 'LLUVIA', 
    'NENA', 'NENE', 'NUBES', 'PARAGUAS', 'SOL', 'VIENTO'
];

// Variables del estado del juego
let currentScore = 0;           // Puntuaci√≥n actual del jugador
let remainingObjects = [...gameObjects];  // Objetos que quedan por adivinar
let currentAudio = null;        // Audio que se est√° reproduciendo actualmente
let currentTargetObject = null; // Objeto que el jugador debe encontrar
let isAudioPlaying = false;     // Control para evitar clicks m√∫ltiples

// Elementos del DOM que usaremos frecuentemente
const startScreen = document.getElementById('startScreen');
const gameScreen = document.getElementById('gameScreen');
const victoryScreen = document.getElementById('victoryScreen');
const startButton = document.getElementById('startButton');
const playAudioButton = document.getElementById('playAudioButton');
const playAgainButton = document.getElementById('playAgainButton');
const scoreDisplay = document.getElementById('score');
const finalScoreDisplay = document.getElementById('finalScore');
const objectsContainer = document.getElementById('objectsContainer');
const marianaStart = document.getElementById('marianaStart');
const marianaGame = document.getElementById('marianaGame');

// =============================================================================
// FUNCIONES DE UTILIDAD
// =============================================================================

/**
 * Funci√≥n para mezclar aleatoriamente un array (algoritmo Fisher-Yates)
 * @param {Array} array - El array que queremos mezclar
 * @returns {Array} - Una copia del array mezclada aleatoriamente
 */
function shuffleArray(array) {
    const shuffled = [...array]; // Crear una copia del array
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; // Intercambiar elementos
    }
    return shuffled;
}

/**
 * Funci√≥n para seleccionar un elemento aleatorio de un array
 * @param {Array} array - El array del cual queremos seleccionar
 * @returns {*} - Un elemento aleatorio del array
 */
function getRandomElement(array) {
    return array[Math.floor(Math.random() * array.length)];
}

/**
 * Funci√≥n para cambiar entre pantallas con transici√≥n suave
 * @param {HTMLElement} hideScreen - Pantalla a ocultar
 * @param {HTMLElement} showScreen - Pantalla a mostrar
 */
function changeScreen(hideScreen, showScreen) {
    hideScreen.classList.remove('active');
    setTimeout(() => {
        showScreen.classList.add('active');
    }, 100);
}

/**
 * Funci√≥n para actualizar la puntuaci√≥n en pantalla
 * @param {number} points - Puntos a sumar
 */
function updateScore(points) {
    currentScore += points;
    scoreDisplay.textContent = `${currentScore}/200`;
}

// =============================================================================
// FUNCIONES DE AUDIO Y ANIMACI√ìN
// =============================================================================

/**
 * Funci√≥n para actualizar el estado visual del bot√≥n de audio
 * @param {string} state - Estado del bot√≥n: 'new', 'playing', 'repeat'
 */
function updateAudioButtonState(state) {
    const button = playAudioButton;
    const buttonText = button.querySelector('.button-text');
    
    button.dataset.state = state;
    
    switch(state) {
        case 'new':
            buttonText.textContent = 'üîä ◊î÷∑◊©÷∞◊Å◊û÷µ◊¢÷∑ ◊ß◊ï÷π◊ú';
            break;
        case 'playing':
            buttonText.textContent = 'üîÑ ◊û÷∑◊©÷∞◊Å◊û÷¥◊ô◊¢÷∑';
            break;
        case 'repeat':
            buttonText.textContent = 'üîÅ ◊î÷∑◊©÷∞◊Å◊û÷µ◊¢÷∑ ◊¢◊ï÷π◊ì ◊§÷∑÷º◊¢÷∑◊ù';
            break;
    }
}

/**
 * Funci√≥n para actualizar el estado visual del bot√≥n de inicio
 * @param {string} state - Estado del bot√≥n: 'start', 'playing'
 */
function updateStartButtonState(state) {
    const button = startButton;
    const buttonText = button.querySelector('.button-text');
    
    switch(state) {
        case 'start':
            buttonText.textContent = 'üöÄ ◊î÷∑◊™÷∞◊ó÷µ◊ú ◊û÷¥◊©÷∞◊Ç◊ó÷∏◊ß üöÄ';
            button.style.pointerEvents = 'auto';
            button.style.cursor = 'pointer';
            button.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
            break;
        case 'playing':
            buttonText.textContent = 'üîÑ ◊û÷∑◊©÷∞◊Å◊û÷¥◊ô◊¢÷∑';
            button.style.pointerEvents = 'none';
            button.style.cursor = 'not-allowed';
            button.style.background = 'linear-gradient(45deg, #FFA726, #FF9800)';
            break;
    }
}

/**
 * Funci√≥n para reproducir audio y animar a Mariana mientras habla
 * @param {string} audioPath - Ruta del archivo de audio
 * @param {HTMLElement} marianaElement - Elemento de imagen de Mariana
 * @param {Function} onComplete - Funci√≥n a ejecutar cuando termina el audio
 */
function playAudioWithAnimation(audioPath, marianaElement, onComplete = null) {
    const audio = new Audio(audioPath);
    let animationInterval;
    
    // Funci√≥n para alternar la imagen de Mariana
    function toggleMarianaImage() {
        const currentSrc = marianaElement.src;
        if (currentSrc.includes('mariana_boca_cerrada.png')) {
            marianaElement.src = 'assets/images/mariana_boca_abierta.png';
        } else {
            marianaElement.src = 'assets/images/mariana_boca_cerrada.png';
        }
    }
    
    // Iniciar la animaci√≥n cuando empiece el audio
    audio.addEventListener('play', () => {
        animationInterval = setInterval(toggleMarianaImage, 300); // Cambiar cada 0.3 segundos
    });
    
    // Detener la animaci√≥n cuando termine el audio
    audio.addEventListener('ended', () => {
        clearInterval(animationInterval);
        marianaElement.src = 'assets/images/mariana_boca_cerrada.png'; // Volver a boca cerrada
        if (onComplete) {
            onComplete();
        }
    });
    
    audio.play();
    return audio;
}

/**
 * Funci√≥n para reproducir audio de un objeto espec√≠fico
 * @param {string} objectName - Nombre del objeto
 */
function playObjectAudio(objectName) {
    if (isAudioPlaying) return; // Evitar clicks m√∫ltiples
    
    isAudioPlaying = true;
    currentTargetObject = objectName;
    
    // Cambiar estado del bot√≥n a "reproduciendo"
    updateAudioButtonState('playing');
    
    const audioPath = `assets/audio/${objectName}.mp3`;
    currentAudio = new Audio(audioPath);
    
    // Iniciar animaci√≥n de Mariana
    let animationInterval = setInterval(() => {
        const currentSrc = marianaGame.src;
        if (currentSrc.includes('mariana_boca_cerrada.png')) {
            marianaGame.src = 'assets/images/mariana_boca_abierta.png';
        } else {
            marianaGame.src = 'assets/images/mariana_boca_cerrada.png';
        }
    }, 300); // Cambiar cada 0.3 segundos
    
    currentAudio.addEventListener('ended', () => {
        // Detener animaci√≥n
        clearInterval(animationInterval);
        marianaGame.src = 'assets/images/mariana_boca_cerrada.png';
        
        isAudioPlaying = false;
        // Cambiar el estado del bot√≥n a "repetir"
        updateAudioButtonState('repeat');
    });
    
    currentAudio.play();
}

// =============================================================================
// FUNCIONES DE MANEJO DEL JUEGO
// =============================================================================

/**
 * Funci√≥n para generar las im√°genes de objetos en la pantalla
 */
function generateGameObjects() {
    objectsContainer.innerHTML = ''; // Limpiar el contenedor
    
    // Mezclar los objetos restantes para mostrar en orden aleatorio
    const shuffledObjects = shuffleArray(remainingObjects);
    
    // Crear elementos para cada objeto
    shuffledObjects.forEach(objectName => {
        const objectDiv = document.createElement('div');
        objectDiv.className = 'game-object';
        objectDiv.dataset.objectName = objectName;
        
        const objectImg = document.createElement('img');
        objectImg.src = `assets/images/${objectName}.png`;
        objectImg.alt = objectName;
        
        objectDiv.appendChild(objectImg);
        
        // Agregar evento de click
        objectDiv.addEventListener('click', () => handleObjectClick(objectName, objectDiv));
        
        objectsContainer.appendChild(objectDiv);
    });
}

/**
 * Funci√≥n para manejar el click en un objeto
 * @param {string} clickedObject - Nombre del objeto clickeado
 * @param {HTMLElement} objectElement - Elemento DOM del objeto
 */
function handleObjectClick(clickedObject, objectElement) {
    if (!currentTargetObject || isAudioPlaying) return; // No hacer nada si no hay audio objetivo
    
    if (clickedObject === currentTargetObject) {
        // ¬°Respuesta correcta!
        handleCorrectAnswer(objectElement);
    } else {
        // Respuesta incorrecta
        handleIncorrectAnswer(objectElement);
    }
}

/**
 * Funci√≥n para crear efectos visuales de celebraci√≥n
 */
function createCelebrationEffect() {
    // Crear confetti simple con emojis
    const celebrationEmojis = ['üéâ', '‚≠ê', '‚ú®', 'üåü', 'üéä'];
    
    for (let i = 0; i < 10; i++) {
        setTimeout(() => {
            const emoji = document.createElement('div');
            emoji.textContent = celebrationEmojis[Math.floor(Math.random() * celebrationEmojis.length)];
            emoji.style.position = 'fixed';
            emoji.style.left = Math.random() * window.innerWidth + 'px';
            emoji.style.top = '-50px';
            emoji.style.fontSize = '30px';
            emoji.style.zIndex = '1000';
            emoji.style.pointerEvents = 'none';
            emoji.style.animation = 'celebrationFall 3s ease-out forwards';
            
            document.body.appendChild(emoji);
            
            // Remover el elemento despu√©s de la animaci√≥n
            setTimeout(() => {
                if (emoji.parentNode) {
                    emoji.parentNode.removeChild(emoji);
                }
            }, 3000);
        }, i * 100);
    }
}

/**
 * Funci√≥n para manejar respuesta correcta
 * @param {HTMLElement} objectElement - Elemento del objeto correcto
 */
function handleCorrectAnswer(objectElement) {
    // Reproducir sonido de respuesta correcta
    const correctSound = new Audio('assets/audio/audio-correct (1).mp3');
    correctSound.play();
    
    // A√±adir animaci√≥n de respuesta correcta
    objectElement.classList.add('correct');
    
    // Crear efecto de celebraci√≥n
    createCelebrationEffect();
    
    // Sumar puntos
    updateScore(10);
    
    // Remover el objeto de la lista de objetos restantes
    remainingObjects = remainingObjects.filter(obj => obj !== currentTargetObject);
    
    // Esperar a que termine la animaci√≥n antes de regenerar objetos
    setTimeout(() => {
        // Verificar si el juego ha terminado
        if (currentScore >= 200) { // 20 objetos √ó 10 puntos = 200 puntos
            showVictoryScreen();
        } else {
            // Continuar el juego
            generateGameObjects();
            selectNewTargetObject();
        }
    }, 800); // Duraci√≥n de la animaci√≥n aumentada
}

/**
 * Funci√≥n para manejar respuesta incorrecta
 * @param {HTMLElement} objectElement - Elemento del objeto incorrecto
 */
function handleIncorrectAnswer(objectElement) {
    // Reproducir sonido de respuesta incorrecta
    const incorrectSound = new Audio('assets/audio/audio-oops (1).mp3');
    incorrectSound.play();
    
    // A√±adir animaci√≥n de respuesta incorrecta
    objectElement.classList.add('incorrect');
    
    // Quitar la animaci√≥n despu√©s de que termine
    setTimeout(() => {
        objectElement.classList.remove('incorrect');
    }, 600);
}

/**
 * Funci√≥n para seleccionar un nuevo objeto objetivo
 */
function selectNewTargetObject() {
    if (remainingObjects.length > 0) {
        currentTargetObject = getRandomElement(remainingObjects);
        updateAudioButtonState('new'); // Resetear estado del bot√≥n
    }
}

/**
 * Funci√≥n para mostrar la pantalla de victoria
 */
function showVictoryScreen() {
    finalScoreDisplay.textContent = currentScore;
    
    // Crear gran efecto de celebraci√≥n para la victoria
    setTimeout(() => {
        for (let i = 0; i < 30; i++) {
            setTimeout(() => {
                createCelebrationEffect();
            }, i * 200);
        }
    }, 500);
    
    changeScreen(gameScreen, victoryScreen);
}

/**
 * Funci√≥n para reiniciar el juego
 */
function resetGame() {
    currentScore = 0;
    remainingObjects = [...gameObjects];
    currentTargetObject = null;
    isAudioPlaying = false;
    scoreDisplay.textContent = '0/200';
    updateAudioButtonState('new');
}

/**
 * Funci√≥n para iniciar el juego principal
 */
function startMainGame() {
    resetGame();
    generateGameObjects();
    selectNewTargetObject();
    changeScreen(startScreen, gameScreen);
}

// =============================================================================
// EVENTOS Y INICIALIZACI√ìN
// =============================================================================

/**
 * Funci√≥n para inicializar la aplicaci√≥n cuando se carga la p√°gina
 */
function initializeGame() {
    console.log('üéÆ Juego de hebreo inicializado');
    
    // Evento para el bot√≥n de inicio
    startButton.addEventListener('click', () => {
        console.log('‚ñ∂Ô∏è Iniciando juego...');
        
        // Cambiar estado del bot√≥n a "reproduciendo"
        updateStartButtonState('playing');
        
        // Reproducir audio de introducci√≥n con animaci√≥n
        playAudioWithAnimation('assets/audio/intro.mp3', marianaStart, () => {
            console.log('üéµ Audio de introducci√≥n completado');
            updateStartButtonState('start'); // Volver al estado normal
            startMainGame();
        });
    });
    
    // Evento para el bot√≥n de reproducir audio
    playAudioButton.addEventListener('click', () => {
        const currentState = playAudioButton.dataset.state;
        
        if (currentState === 'playing') {
            // No hacer nada si est√° reproduciendo
            return;
        }
        
        if (currentTargetObject) {
            console.log(`üîä Reproduciendo audio para: ${currentTargetObject}`);
            playObjectAudio(currentTargetObject);
        }
    });
    
    // Evento para el bot√≥n de jugar otra vez
    playAgainButton.addEventListener('click', () => {
        console.log('üîÑ Reiniciando juego...');
        changeScreen(victoryScreen, startScreen);
    });
}

// Inicializar el juego cuando se carga la p√°gina
document.addEventListener('DOMContentLoaded', initializeGame);

// =============================================================================
// MANEJO DE ERRORES
// =============================================================================

/**
 * Funci√≥n para manejar errores de audio
 */
function handleAudioError(audioPath, errorMsg) {
    console.error(`‚ùå Error cargando audio ${audioPath}: ${errorMsg}`);
    // Podr√≠as mostrar un mensaje al usuario o usar un audio alternativo
}

// Agregar manejo de errores a los audios
window.addEventListener('error', (e) => {
    if (e.target.tagName === 'AUDIO') {
        handleAudioError(e.target.src, e.message);
    }
}, true);

// =============================================================================
// INFORMACI√ìN DE DESARROLLO
// =============================================================================

console.log(`
üéÆ JUEGO DE HEBREO CON OBJETOS üéÆ
================================
üìö Objetos disponibles: ${gameObjects.length}
üéØ Puntuaci√≥n m√°xima: 200 puntos
üéµ Archivos de audio: intro.mp3, audio-correct (1).mp3, audio-oops (1).mp3 + 20 objetos
üñºÔ∏è Archivos de imagen: mariana_boca_abierta.png, mariana_boca_cerrada.png + 20 objetos
================================
Desarrollado para ni√±os de 4-5 a√±os aprendiendo hebreo con niqqud
`);
